"""
Integration tests for MCP API tools.

Tests the full integration of MCP tools with the memory system including:
- Tool parameter validation
- Memory operations through tool interface
- Error handling and response formatting
- Tool interaction workflows
- Performance of tool operations
"""

import json
import pytest
from typing import Dict, Any
from unittest.mock import AsyncMock, patch

from mcp_assoc_memory.api.tools.memory_tools import (
    handle_memory_search,
    handle_memory_manage,
    handle_memory_store
)
from mcp_assoc_memory.api.tools.scope_tools import (
    handle_scope_list,
    handle_scope_suggest
)
from mcp_assoc_memory.core.memory_manager import MemoryManager


class TestMemoryToolsIntegration:
    """Integration tests for memory-related MCP tools."""
    
    @pytest.mark.asyncio
    async def test_memory_search_tool_success(self, populated_memory_manager: MemoryManager):
        """Test memory search tool with valid parameters."""
        arguments = {
            "request": {
                "query": "programming",
                "limit": 5,
                "mode": "standard",
                "similarity_threshold": 0.1
            }
        }
        
        result = await handle_memory_search(arguments, populated_memory_manager)
        
        assert result["success"] is True
        assert "data" in result
        assert isinstance(result["data"], list)
        
        # Verify response structure
        if result["data"]:
            memory = result["data"][0]
            assert "memory_id" in memory
            assert "content" in memory
            assert "similarity_score" in memory
            assert "scope" in memory
    
    @pytest.mark.asyncio
    async def test_memory_search_tool_diversified_mode(self, populated_memory_manager: MemoryManager):
        """Test memory search tool with diversified mode."""
        arguments = {
            "request": {
                "query": "learning",
                "limit": 3,
                "mode": "diversified",
                "similarity_threshold": 0.1,
                "diversity_threshold": 0.8
            }
        }
        
        result = await handle_memory_search(arguments, populated_memory_manager)
        
        assert result["success"] is True
        assert isinstance(result["data"], list)
    
    @pytest.mark.asyncio
    async def test_memory_search_tool_invalid_mode(self, test_memory_manager: MemoryManager):
        """Test memory search tool with invalid mode."""
        arguments = {
            "request": {
                "query": "test",
                "mode": "invalid_mode"
            }
        }
        
        result = await handle_memory_search(arguments, test_memory_manager)
        
        assert result["success"] is False
        assert "mode" in result["message"].lower()
    
    @pytest.mark.asyncio
    async def test_memory_store_tool_success(self, test_memory_manager: MemoryManager):
        """Test memory store tool with valid parameters."""
        arguments = {
            "request": {
                "content": "Test content for tool integration",
                "scope": "test/integration",
                "category": "test",
                "tags": ["integration", "test"],
                "metadata": {"source": "integration_test"},
                "minimal_response": False
            }
        }
        
        result = await handle_memory_store(arguments, test_memory_manager)
        
        assert result["success"] is True
        assert result["data"]["content"] == "Test content for tool integration"
        assert result["data"]["scope"] == "test/integration"
        assert result["data"]["category"] == "test"
        assert result["data"]["tags"] == ["integration", "test"]
        assert result["data"]["metadata"]["source"] == "integration_test"
    
    @pytest.mark.asyncio
    async def test_memory_store_tool_minimal_response(self, test_memory_manager: MemoryManager):
        """Test memory store tool with minimal response."""
        arguments = {
            "request": {
                "content": "Test content for minimal response",
                "scope": "test/minimal",
                "minimal_response": True
            }
        }
        
        result = await handle_memory_store(arguments, test_memory_manager)
        
        assert result["success"] is True
        assert "memory_id" in result["data"]
        # Minimal response should not include full content
        assert "content" not in result["data"] or result["data"]["content"] == "[Content hidden for minimal response]"
    
    @pytest.mark.asyncio
    async def test_memory_manage_tool_get_operation(self, populated_memory_manager: MemoryManager):
        """Test memory manage tool with get operation."""
        # First get a memory ID
        all_memories = await populated_memory_manager.get_all_memories()
        memory_id = all_memories[0]["memory_id"]
        
        arguments = {
            "request": {
                "operation": "get",
                "memory_id": memory_id,
                "include_associations": True
            }
        }
        
        result = await handle_memory_manage(arguments, populated_memory_manager)
        
        assert result["success"] is True
        assert result["data"]["memory_id"] == memory_id
        assert "content" in result["data"]
        assert "associations" in result["data"]
    
    @pytest.mark.asyncio
    async def test_memory_manage_tool_update_operation(self, populated_memory_manager: MemoryManager):
        """Test memory manage tool with update operation."""
        # First get a memory ID
        all_memories = await populated_memory_manager.get_all_memories()
        memory_id = all_memories[0]["memory_id"]
        
        arguments = {
            "request": {
                "operation": "update",
                "memory_id": memory_id,
                "content": "Updated content through tool",
                "category": "updated",
                "tags": ["updated", "tool-test"]
            }
        }
        
        result = await handle_memory_manage(arguments, populated_memory_manager)
        
        assert result["success"] is True
        assert result["data"]["content"] == "Updated content through tool"
        assert result["data"]["category"] == "updated"
        assert result["data"]["tags"] == ["updated", "tool-test"]
    
    @pytest.mark.asyncio
    async def test_memory_manage_tool_delete_operation(self, populated_memory_manager: MemoryManager):
        """Test memory manage tool with delete operation."""
        # Store a memory to delete
        store_result = await populated_memory_manager.store_memory(
            content="Memory to delete",
            scope="test/delete"
        )
        memory_id = store_result["data"]["memory_id"]
        
        arguments = {
            "request": {
                "operation": "delete",
                "memory_id": memory_id
            }
        }
        
        result = await handle_memory_manage(arguments, populated_memory_manager)
        
        assert result["success"] is True
        assert result["data"]["deleted"] is True
    
    @pytest.mark.asyncio
    async def test_memory_manage_tool_invalid_operation(self, test_memory_manager: MemoryManager):
        """Test memory manage tool with invalid operation."""
        arguments = {
            "request": {
                "operation": "invalid_operation",
                "memory_id": "test-id"
            }
        }
        
        result = await handle_memory_manage(arguments, test_memory_manager)
        
        assert result["success"] is False
        assert "operation" in result["message"].lower()


class TestScopeToolsIntegration:
    """Integration tests for scope-related MCP tools."""
    
    @pytest.mark.asyncio
    async def test_scope_list_tool_success(self, populated_memory_manager: MemoryManager):
        """Test scope list tool with valid parameters."""
        arguments = {
            "request": {
                "include_memory_counts": True,
                "parent_scope": None
            }
        }
        
        result = await handle_scope_list(arguments, populated_memory_manager)
        
        assert result["success"] is True
        assert isinstance(result["data"], list)
        
        # Verify scope structure
        if result["data"]:
            scope = result["data"][0]
            assert "scope" in scope
            assert "memory_count" in scope
    
    @pytest.mark.asyncio
    async def test_scope_list_tool_with_parent(self, populated_memory_manager: MemoryManager):
        """Test scope list tool with parent scope filter."""
        arguments = {
            "request": {
                "include_memory_counts": True,
                "parent_scope": "learning"
            }
        }
        
        result = await handle_scope_list(arguments, populated_memory_manager)
        
        assert result["success"] is True
        
        # All scopes should be under the learning parent
        for scope in result["data"]:
            assert scope["scope"].startswith("learning")
    
    @pytest.mark.asyncio
    async def test_scope_suggest_tool_success(self, test_memory_manager: MemoryManager):
        """Test scope suggest tool with valid content."""
        arguments = {
            "request": {
                "content": "This is about Python web development using FastAPI and databases",
                "current_scope": None
            }
        }
        
        result = await handle_scope_suggest(arguments, test_memory_manager)
        
        assert result["success"] is True
        assert "suggested_scope" in result["data"]
        assert "confidence" in result["data"]
        assert "alternatives" in result["data"]
        
        # Verify confidence is a valid value
        confidence = result["data"]["confidence"]
        assert isinstance(confidence, float)
        assert 0 <= confidence <= 1
    
    @pytest.mark.asyncio
    async def test_scope_suggest_tool_with_context(self, test_memory_manager: MemoryManager):
        """Test scope suggest tool with current scope context."""
        arguments = {
            "request": {
                "content": "Advanced machine learning concepts and neural networks",
                "current_scope": "learning/ml"
            }
        }
        
        result = await handle_scope_suggest(arguments, test_memory_manager)
        
        assert result["success"] is True
        # Suggested scope should be related to current scope context
        suggested_scope = result["data"]["suggested_scope"]
        assert "learning" in suggested_scope or "ml" in suggested_scope


class TestToolErrorHandling:
    """Test error handling across MCP tools."""
    
    @pytest.mark.asyncio
    async def test_missing_required_parameters(self, test_memory_manager: MemoryManager):
        """Test tools with missing required parameters."""
        # Test memory store without content
        arguments = {
            "request": {
                "scope": "test/scope"
                # Missing required 'content' parameter
            }
        }
        
        result = await handle_memory_store(arguments, test_memory_manager)
        
        assert result["success"] is False
        assert "content" in result["message"].lower()
    
    @pytest.mark.asyncio
    async def test_invalid_parameter_types(self, test_memory_manager: MemoryManager):
        """Test tools with invalid parameter types."""
        # Test memory search with invalid limit type
        arguments = {
            "request": {
                "query": "test",
                "limit": "invalid_number"  # Should be integer
            }
        }
        
        result = await handle_memory_search(arguments, test_memory_manager)
        
        assert result["success"] is False
    
    @pytest.mark.asyncio
    async def test_tool_exception_handling(self, test_memory_manager: MemoryManager):
        """Test tool exception handling."""
        # Mock an exception in the memory manager
        with patch.object(test_memory_manager, 'search_memories') as mock_search:
            mock_search.side_effect = Exception("Internal error")
            
            arguments = {
                "request": {
                    "query": "test",
                    "mode": "standard"
                }
            }
            
            result = await handle_memory_search(arguments, test_memory_manager)
            
            assert result["success"] is False
            assert "error" in result["message"].lower()


class TestToolPerformance:
    """Test performance characteristics of MCP tools."""
    
    @pytest.mark.asyncio
    @pytest.mark.slow
    async def test_search_tool_performance(self, populated_memory_manager: MemoryManager):
        """Test search tool performance with large result sets."""
        import time
        
        arguments = {
            "request": {
                "query": "test",
                "limit": 50,
                "mode": "standard"
            }
        }
        
        start_time = time.time()
        result = await handle_memory_search(arguments, populated_memory_manager)
        end_time = time.time()
        
        duration = end_time - start_time
        
        assert result["success"] is True
        # Tool should respond quickly
        assert duration < 10.0  # 10 seconds threshold
    
    @pytest.mark.asyncio
    @pytest.mark.slow
    async def test_bulk_store_tool_performance(self, test_memory_manager: MemoryManager):
        """Test store tool performance for multiple operations."""
        import time
        
        start_time = time.time()
        
        # Store multiple memories sequentially
        for i in range(5):
            arguments = {
                "request": {
                    "content": f"Performance test memory {i}",
                    "scope": f"performance/test{i}",
                    "minimal_response": True
                }
            }
            
            result = await handle_memory_store(arguments, test_memory_manager)
            assert result["success"] is True
        
        end_time = time.time()
        duration = end_time - start_time
        
        # Should complete bulk operations in reasonable time
        assert duration < 15.0  # 15 seconds for 5 operations


class TestToolWorkflows:
    """Test end-to-end workflows using multiple tools."""
    
    @pytest.mark.asyncio
    async def test_store_search_workflow(self, test_memory_manager: MemoryManager):
        """Test store -> search workflow."""
        # Store a memory
        store_args = {
            "request": {
                "content": "Workflow test content about Python programming",
                "scope": "test/workflow",
                "category": "programming",
                "tags": ["python", "workflow"]
            }
        }
        
        store_result = await handle_memory_store(store_args, test_memory_manager)
        assert store_result["success"] is True
        memory_id = store_result["data"]["memory_id"]
        
        # Search for the stored memory
        search_args = {
            "request": {
                "query": "Python programming workflow",
                "mode": "standard",
                "limit": 10
            }
        }
        
        search_result = await handle_memory_search(search_args, test_memory_manager)
        assert search_result["success"] is True
        
        # Verify the stored memory appears in search results
        found_memory = None
        for memory in search_result["data"]:
            if memory["memory_id"] == memory_id:
                found_memory = memory
                break
        
        assert found_memory is not None
        assert "Python programming" in found_memory["content"]
    
    @pytest.mark.asyncio
    async def test_store_manage_workflow(self, test_memory_manager: MemoryManager):
        """Test store -> manage (get/update/delete) workflow."""
        # Store a memory
        store_args = {
            "request": {
                "content": "Memory for management workflow",
                "scope": "test/management"
            }
        }
        
        store_result = await handle_memory_store(store_args, test_memory_manager)
        assert store_result["success"] is True
        memory_id = store_result["data"]["memory_id"]
        
        # Get the memory
        get_args = {
            "request": {
                "operation": "get",
                "memory_id": memory_id
            }
        }
        
        get_result = await handle_memory_manage(get_args, test_memory_manager)
        assert get_result["success"] is True
        assert get_result["data"]["memory_id"] == memory_id
        
        # Update the memory
        update_args = {
            "request": {
                "operation": "update",
                "memory_id": memory_id,
                "content": "Updated memory for workflow",
                "category": "updated"
            }
        }
        
        update_result = await handle_memory_manage(update_args, test_memory_manager)
        assert update_result["success"] is True
        assert update_result["data"]["content"] == "Updated memory for workflow"
        
        # Delete the memory
        delete_args = {
            "request": {
                "operation": "delete",
                "memory_id": memory_id
            }
        }
        
        delete_result = await handle_memory_manage(delete_args, test_memory_manager)
        assert delete_result["success"] is True
        assert delete_result["data"]["deleted"] is True
